{"name":"Batali","tagline":"Light weight cookbook resolver","body":"# Batali\r\n\r\nBatali is a light weight cookbook resolver. It is now in\r\na beta state, moving quickly towards a proper stable release.\r\n\r\n## What is Batali?\r\n\r\nBatali is a cookbook resolver. It's built to be light weight\r\nbut feature rich. Batali helps to manage your cookbooks and\r\nstay out of your way.\r\n\r\n## Usage\r\n\r\nProvide a `Batali` file:\r\n\r\n```ruby\r\nBatali.define do\r\n  source 'https://supermarket.chef.io'\r\n  cookbook 'postgresql'\r\nend\r\n```\r\n\r\nand then run:\r\n\r\n```\r\n$ batali update\r\n```\r\n\r\nin the same directory. It will destroy your `cookbooks` directory\r\nby default.\r\n\r\n_IT WILL DESTROY YOUR COOKBOOKS DIRECTORY BY DEFAULT_\r\n\r\nYou can make it not destroy your cookbooks directory by providing\r\na different path. A better idea is to not use the cookbooks directory.\r\nJust ignore that sucker and let Batali do its thing.\r\n\r\n## Commands\r\n\r\n* `batali resolve` - Resolve dependencies and produce `batali.manifest`\r\n* `batali install` - Install entries from the `batali.manifest`\r\n* `batali update`  - Perform `resolve` and then `install`\r\n\r\n## Features\r\n\r\n### Origins\r\n\r\nCurrently supported \"origins\":\r\n\r\n* RemoteSite\r\n* Path\r\n* Git\r\n\r\n#### RemoteSite\r\n\r\nThis is simply a supermarket endpoint:\r\n\r\n```ruby\r\nsource 'https://supermarket.chef.io'\r\n```\r\n\r\nMultiple endpoints can be provided by specifying multiple\r\n`source` lines. They can also be named:\r\n\r\n```ruby\r\nsource 'https://supermarket.chef.io', :name => 'opscode'\r\nsource 'https://cookbooks.example.com', :name => 'example'\r\n```\r\n\r\n##### Path\r\n\r\nPaths are defined via cookbook entries:\r\n\r\n```ruby\r\ncookbook 'example', path: '/path/to/example'\r\n```\r\n\r\n##### Git\r\n\r\nGit sources are defined via cookbook entries:\r\n\r\n```ruby\r\ncookbook 'example', git: 'git://git.example.com/example-repo.git', ref: 'master'\r\n```\r\n\r\n### Least Impact Updates\r\n\r\nAfter a `batali.manifest` file has been generated, subsequent `resolve` requests\r\nwill update cookbook versions using a \"least impact\" approach. This means that\r\nby default if the `Batali` file has not changed, running a `batali resolve` will\r\nbe a noop, even if new versions of cookbooks may be available. This helps to reduce\r\nunintended upgrades that may break things due to a required cookbook update. Allowing\r\na cookbook to be updated is done simply by adding it to the request:\r\n\r\n```\r\n$ batali resolve example\r\n```\r\n\r\nThis will only update the version of the example cookbook, and any dependency cookbooks\r\nthat _must_ be updated to provide resolution. Dependency cookbooks that require an upgrade\r\nbased on constraints will attempt to upgrade with the _least impact possible_ by attempting\r\nto satisfy constraints within the minimum version segement possible. For example, if our\r\nBatali file contains the following:\r\n\r\n```ruby\r\nBatali.define do\r\n  source 'https://example.com'\r\n  cookbook 'soup'\r\nend\r\n```\r\n\r\nand after resolving we have two cookbooks in our manifest:\r\n\r\n```\r\nsoup <1.0.0>\r\nsalad <0.1.4>\r\n```\r\n\r\nSome time passes and a new version of `soup` is released, version 1.0.2. In that time\r\nmultiple new versions of the `salad` cookbook have been released, with new features and\r\nwith some breaking changes. For this example, lets assume available versions of the `salad`\r\ncookbook are:\r\n\r\n```\r\n<0.1.4>\r\n<0.1.6>\r\n<0.1.8>\r\n<0.2.0>\r\n<0.2.2>\r\n<0.3.0>\r\n<1.0.0>\r\n```\r\n\r\nand the `soup` cookbook has updated its `salad` dependency:\r\n\r\n```ruby\r\n# soup metadata.rb\r\ndepends 'salad', '> 0.2'\r\n```\r\n\r\nDue to the behavior of existing solvers, we may expect the resolved manifest to include\r\n`salad` at the latest possible version: `1.0.0`. This is a valid solution, since the\r\ndependency is simply stating the constraint requires `salad` be _greater_ than `0.2` and\r\nnothing more. However, this is a very large jump from what we currently have defined\r\nwithin our manifest, and jumps a major and minor version. The possibility of breaking\r\nchanges being introduced is extremely high.\r\n\r\nSince Batali has the **least impact** feature enabled by default, it will only upgrade\r\n`salad` to the `0.2.2` version. This is due to the fact that the **least impact** feature\r\nprefers the _latest_ cookbook available within the _closest_ version segement of the cookbook\r\nversion currently defined within the manifest. Since thew new `soup` dependency contraint\r\nrequires versions `> 0.2`, no `> 0.1` versions are acceptable. Batali then looks to the\r\nnext available segment `0.2` and attempts to use the latest version: `0.2.2`. This solves the\r\nconstraint, and is used for the new solution.\r\n\r\nMultiple cookbooks can be listed for upgrade:\r\n\r\n```\r\n$ batali resolve example ipsum lorem\r\n```\r\n\r\nor this feature can be disabled to allow everything to be updated to the latest\r\npossible versions:\r\n\r\n```\r\n$ batali resolve --no-least-impact\r\n```\r\n\r\n### Light weight\r\n\r\nOne of the goals for batali was being light weight resolver, in the same vein as\r\nthe [librarian][1] project. This means it does nothing more than manage local cookbooks. This\r\nincludes dependency and constraint resolution, as well as providing a local installation\r\nof assets defined within the generated manifest. It provides no extra features outside of\r\nthat scope.\r\n\r\n### Multiple platform support\r\n\r\nBatali does not rely on the [chef][2] gem to function. This removes any dependencies on\r\ngems that may be incompatible outside the MRI platform.\r\n\r\n### Isolated manifest files\r\n\r\nManifest files are fully isolated. The resolver does not need to perform any actions\r\nfor installing cookbooks defined within the manifest. This allows for easy transmission\r\nand direct installation of a manifest without the requirement of re-pulling information\r\nfrom sources.\r\n\r\n### Infrastructure manifests\r\n\r\nBatali aims to solve the issue of full infrastructure resolution: resolving dependencies\r\nfrom an infrastructure repository. Resolving a single dependency path will not provide\r\na correct resolution. This is because environments or run lists can provide extra constraints\r\nthat will result in unsolvable resolutions on individual nodes. In this case we want\r\nto know what cookbooks are _allowed_ within a solution, and ensure all those cookbooks\r\nare available. Batali provides infrastructure level manifests by setting the `infrastructure`\r\nflag:\r\n\r\n```\r\n$ batali resolve --infrastructure\r\n```\r\n\r\n_NOTE: Depending on constraints defined within the Batali file, this can be a very large manifest_\r\n\r\n#### Uploading infrastructure cookbooks\r\n\r\nWhen the infrastructure cookbooks are installed locally, the cookbook directories will have\r\nthe version number as a suffix. This can cause a problem when attempting to run:\r\n\r\n```\r\n$ knife cookbook upload --all\r\n```\r\n\r\ndue to knife using the directory name as the actual cookbook name. To get around this problem\r\nthe `upload` command can be used directly with the correct options enabled. These options must\r\nbe defined within the config file as the options are not accessible via CLI flags. Assuming\r\na `.chef/knife.rb` file exists:\r\n\r\n```ruby\r\n# .chef/knife.rb\r\n\r\nversioned_cookbooks true\r\n```\r\n\r\n```\r\n$ knife upload cookbooks\r\n```\r\n\r\n### Display outdated cookbooks\r\n\r\nWant to see what cookbooks have newer versions available within the defined constraints? Use\r\nthe dry run option to see what upgrades are available without actually changing the manifest:\r\n\r\n```\r\n$ batali resolve --no-least-impact --dry-run\r\n```\r\n\r\n### Automatic cookbook discovery\r\n\r\nTired of tracking constraints in multiple places when using Chef Environment `cookbook_versions`\r\nfor environment specific constraints? Let Batali manage it for you! Define your `Batali` file\r\nto enable automatic discovery:\r\n\r\n```ruby\r\nBatali.define do\r\n  source 'https://example.com'\r\n  discover true\r\nend\r\n```\r\n\r\nThat's it! Now you can resolve for the infrastructure:\r\n\r\n```\r\n$ batali resolve --infrastructure\r\n```\r\n\r\nwhich will generate a resulting manifest that includes all required cookbook versions to\r\nsatisfiy constraints defined by all environments.\r\n\r\n## Configuration\r\n\r\nBatali can be configured via the `.batali` file. The contents of the file can be in YAML,\r\nJSON, XML, or Ruby. Every option displayed via the help call can be set within this file.\r\nThe configuration can hold items isolated within a command's name, or defined at the top\r\nlevel of the configuration file. For example:\r\n\r\n```ruby\r\nConfiguration.new do\r\n  debug true\r\n  resolve do\r\n    debug false\r\n  end\r\nend\r\n```\r\n\r\nThis configuration turns debug output on for all commands _except_ the resolve command.\r\nThis feature is handy in situations where multiple commands may have the same flag that\r\nshould always be enabled, like the `infrastructure` flag:\r\n\r\n```ruby\r\nConfiguration.new do\r\n  infrastructure true\r\nend\r\n```\r\n\r\nWhen flags on the CLI contain a dash, they are referenced within the configuration file\r\nas an underscore. For example the least impact flag on the CLI looks like:\r\n\r\n```\r\n--least-impact\r\n```\r\n\r\nand the key in the configuration looks like:\r\n\r\n```\r\nleast_impact\r\n```\r\n\r\n### Example configurations\r\n\r\n#### Ruby\r\n\r\n```ruby\r\nConfiguration.new do\r\n  infrastructure true\r\n  resolve do\r\n    least_impact false\r\n  end\r\nend\r\n```\r\n\r\n#### JSON\r\n\r\n```json\r\n{\r\n  \"infrastructure\": true,\r\n  \"resolve\": {\r\n    \"least_impact\": false\r\n  }\r\n}\r\n```\r\n\r\n#### YAML\r\n\r\n```yaml\r\n---\r\n:infrastructure: true\r\n:resolve:\r\n  :least_impact: false\r\n```\r\n\r\n#### XML\r\n\r\n```xml\r\n<configuration>\r\n  <infrastructure>true</infrastructure>\r\n  <resolve>\r\n    <least_impact>false</least_impact>\r\n  </resolve>\r\n</configuration>\r\n```\r\n\r\n## Test Kitchen\r\n\r\nBatali can be used with [Test Kitchen](https://github.com/test-kitchen/test-kitchen):\r\n\r\n* https://github.com/hw-labs/batali-tk\r\n\r\n## ChefSpec\r\n\r\nBatali can be used with [ChefSpec](https://github.com/sethvargo/chefspec). Add the following\r\nline to your `spec_helper.rb` file:\r\n\r\n```ruby\r\nrequire 'batali/chefspec'\r\n```\r\n\r\n# Info\r\n\r\n* Repository: https://github.com/hw-labs/batali\r\n\r\n[1]: https://rubygems.org/gems/librarian \"A Framework for Bundlers\"\r\n[2]: https://rubygems.org/gems/chef \"A systems integration framework\"","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}